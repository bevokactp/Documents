
import math


def найти_точки_пересђченія_двухъ_окружностей(х1, у1, радіусъ1, х2, у2, радіусъ2):

	протяжённость_мђжду_центрами = найти_протяжённость_мђжду_точками(х1, у1, х2, у2)
	
	# совпадаютъ
	if протяжённость_мђжду_центрами == 0 and радіусъ1 == радіусъ2:
		return 1
	
	# не касаются
	# одна внутри другой
	elif протяжённость_мђжду_центрами > радіусъ1 + радіусъ2:
		return 0
	# не одна внутри другой
	elif протяжённость_мђжду_центрами < abs(радіусъ1 - радіусъ2):
		return 0
	
	# пересђченђ въ двухъ точкахъ
	
	# протяжённость_отъ_центра1_къ_отвесу_точекъ_пересђченія_на_отрђзокъ_мђжду_центрами
	протяжённость_азъ = (math.pow(радіусъ1, 2) - math.pow(радіусъ2, 2) + math.pow(протяжённость_мђжду_центрами, 2)) / (2 * протяжённость_мђжду_центрами)
	
	# протяжённость_высоты_отъ_точки_пересђченія_на_отрђзокъ_мђжду_центрами
	протяжённость_высоты = math.sqrt(math.pow(радіусъ1, 2) - math.pow(протяжённость_азъ, 2))

	# xу высота_на_отрђзке_мђжду_центрами
	x3 = х1 + протяжённость_азъ / протяжённость_мђжду_центрами * (х2 - х1) 
	у3 = у1 + протяжённость_азъ / протяжённость_мђжду_центрами * (у2 - у1) 
	
	х_точка1_пересђченія = x3 + протяжённость_высоты / протяжённость_мђжду_центрами * (у2 - у1)
	у_точка1_пересђченія = у3 - протяжённость_высоты / протяжённость_мђжду_центрами * (х2 - х1)

	х_точка2_пересђченія = x3 - протяжённость_высоты / протяжённость_мђжду_центрами * (у2 - у1)
	у_точка2_пересђченія = у3 + протяжённость_высоты / протяжённость_мђжду_центрами * (х2 - х1)

	# частный случай касанія въ одной точке
	if х_точка1_пересђченія == х_точка2_пересђченія and у_точка1_пересђченія == у_точка2_пересђченія:
		return (х_точка1_пересђченія, у_точка1_пересђченія)
	
	return (х_точка1_пересђченія, у_точка1_пересђченія,
		х_точка2_пересђченія, у_точка2_пересђченія)


def найти_радіусъ_вписаной_окружности_в_равнобедреный_треугольникъ(радіусъ, уголъ_у_центра):
	
	уголъ_у_основания = (180 - уголъ_у_центра) / 2
	танга = радіусъ / math.sin(math.radians(уголъ_у_основания))
	return танга * math.cos(math.radians(уголъ_у_основания)) * math.tan(math.radians(уголъ_у_основания/2))


def опредлить_радіусъ_черезъ_длину_дуги_и_уголъ_при_центре(длина_дуги, уголъ_при_центре):
	
	return длина_дуги / math.radians(уголъ_при_центре)


def входитъ_ли_точка_строго_в_прямоугольникъ(х_діагонально_1, у_діагонально_1, х_діагонально_2, у_діагонально_2, хт, ут):

	if х_діагонально_1 == хт or х_діагонально_2 == хт or у_діагонально_1 == ут or у_діагонально_2 == ут:
		return 0
	a = [х_діагонально_1, хт, х_діагонально_2]
	a.sort()
	if a[1] == хт:
		a = [у_діагонально_1, ут, у_діагонально_2]
		a.sort()
		return a[1] == ут
	return 0


def определить_длину_отрезка_по_точкамъ(х1, у1, х2, у2):
	
	return round(math.sqrt((х2 - х1) ** 2 + (у2 - у1) ** 2), 3)


def найти_уголъ_при_центре_по_радіусу_и_длугости_хорды(длина_хорды, радіусъ):
	
	return math.asin(длина_хорды / (радіусъ * 2))


def входитъ_ли_окружность_въ_окружность(х, у, радиусъ, х0, у0, радіусъ0):
	
	длугость_мђжду_центрами_окружностей = определить_длину_отрезка_по_точкамъ(х, у, х0, у0)
	return длугость_мђжду_центрами_окружностей + радиусъ <= радіусъ0


def найти_уголъ_при_вершине_равнобедренного_треугольника_зная_стороны(равнобедренная_сторона, сторона_у_основания):

	уголъ_у_основания = math.degrees(math.acos(сторона_у_основания / (2 * равнобедренная_сторона)))
	a = 180 - 2 * уголъ_у_основания
	return 180 - 2 * уголъ_у_основания


def найти_длину_дуги_окружности(радіусъ, уголъ):

	return math.pi * радіусъ * уголъ / 180


def найти_протяжённость_мђжду_точками(х1, у1, х2, у2):

	return math.sqrt((х2 - х1) ** 2 + (у2 - у1) ** 2)


def найти_точку_пересђченія_двухъ_прямыхъ(х11, у11, х12, у12, х21, у21, х22, у22):

	d = (у22 - у21) * (х12 - х11) - (х22 - х21) * (у12 - у11)
	if d:
		uA = ((х22 - х21) * (у11 - у21) - (у22 - у21) * (х11 - х21)) / d
		uB = ((х12 - х11) * (у11 - у21) - (у12 - у11) * (х11 - х21)) / d
		if 0 <= uA <= 1 and 0 <= uB <= 1:
			x = х11 + uA * (х12 - х11)
			y = у11 + uA * (у12 - у11)
			return x, y
	return


def найти_точки_пересђченія_прямой_и_окружности_въ_x0y0(х1, у1, х2, у2, х0, у0, радіусъ0):
	# центр о въ 0,0

	dх = х2 - х1
	dу = у2 - у1

	dr = math.sqrt(math.pow(dх, 2) + math.pow(dу, 2))

	D = х1 * у2 - х2 * у1

	delta = math.pow(радіусъ0, 2) * math.pow(dr, 2) - math.pow(D, 2)

	if delta < 0:
		return 0
	elif delta == 0:
		х = (D * dу + (-1 if dу < 0 else 1) * dх * math.sqrt(delta)) / math.pow(dr, 2)
		у = (-D * dх + abs(dу) * math.sqrt(delta)) / math.pow(dr, 2)
		return (х, у)
	return 2,



eps = 1e-14


def within(x1, y1, x2, y2, x, y):
    протяжённость_мђжду_крайними_точками = math.sqrt(math.pow((x2 - x1), 2) + math.pow((y2 - y1), 2))    
    протяжённость_отъ_точки_въ_одинъ_конецъ = math.sqrt(math.pow((x - x1), 2) + math.pow((y - y1), 2))
    протяжённость_отъ_точки_въ_другой_конецъ = math.sqrt(math.pow((x2 - x), 2) + math.pow((y2 - y), 2))
    delta = протяжённость_мђжду_крайними_точками - протяжённость_отъ_точки_въ_одинъ_конецъ - протяжённость_отъ_точки_въ_другой_конецъ
    # true if delta is less than a small tolerance
    return abs(delta) < eps   


# ! возвращаетъ всђгда какъ прямая а не wђзокъ
def rxy(x1, y1, x2, y2, x, y, это_прямая):
    if not это_прямая or within(x1, y1, x2, y2, x, y):
        return 1
    return 0


fx = lambda A, B, C, x: -(A * x + C) / B

fy = lambda A, B, C, y: -(B * y + C) / A


# ! возвращаетъ -0.0
def intersects(x1, y1, x2, y2, x0, y0, r, это_прямая):
    A = y2 - y1
    B = x1 - x2
    C = x2 * y1 - x1 * y2
    a = math.pow(A, 2) + math.pow(B, 2)
    bnz = True
    cnt = 0

    if (abs(B) >= eps):
        # if B isn't zero or close to it
        b = 2 * (A * C + A * B * y0 - math.pow(B, 2) * x0)
        c = math.pow(C, 2) + 2 * B * C * y0 - math.pow(B, 2) * (math.pow(r, 2) - math.pow(x0, 2) - math.pow(y0, 2))
    else:
        b = 2 * (B * C + A * B * x0 - math.pow(A, 2) * y0)
        c = math.pow(C, 2) + 2 * A * C * x0 - math.pow(A, 2) * (math.pow(r, 2) - math.pow(x0, 2) - math.pow(y0, 2))
        bnz = False
   
    discriminant = math.pow(b, 2) - 4 * a * c
    

    # касательная
    if discriminant == 0:
        if bnz:
            x = -b / (2 * a)
            y = fx(A, B, C, x)
            cnt = rxy(x1, y1, x2, y2, x, y, это_прямая)
        else:
            y = -b / (2 * a)
            x = fy(A, B, C, y)
            cnt = rxy(x1, y1, x2, y2, x, y, это_прямая)
        if cnt > 0:
            return (x, y)

    # сђкущая
    else:
        discriminant = math.sqrt(discriminant)
        if bnz:
            x_1 = (-b + discriminant) / (2 * a)
            y_1 = fx(A, B, C, x_1)
            cnt = rxy(x1, y1, x2, y2, x_1, y_1, это_прямая)

            x_2 = (-b - discriminant) / (2 * a)
            y_2 = fx(A, B, C, x_2)
            cnt += rxy(x1, y1, x2, y2, x_2, y_2, это_прямая)
        else:
            y_1 = (-b + discriminant) / (2 * a)
            x_1 = fy(A, B, C, y_1)
            cnt = rxy(x1, y1, x2, y2, x_1, y_1, это_прямая)

            y_2 = (-b - discriminant) / (2 * a)
            x_2 = fy(A, B, C, y_2)
            cnt += rxy(x1, y1, x2, y2, x_2, y_2, это_прямая)
        if cnt > 0:
            return ((x_1, y_1), (x_2, y_2))
       
    # непересђкаемые если дискриминант < 0 или cnt <= 0
    return


def найти_точки_пересђченія_прямой_и_окружности(х1, у1, х2, у2, х0, у0, радіусъ0, это_прямая, arr):

    print("({} {}) {} ({} {} {} {}) = {} = {}".format(
    	х0, у0, радіусъ0, х1, у1, х2, у2, arr, 
    	intersects(х1, у1, х2, у2, х0, у0, радіусъ0, это_прямая)))


найти_точки_пересђченія_прямой_и_окружности(-10, 11, 10, -9, 3, -5, 3, True, "(6, -5)(3, -2)")
найти_точки_пересђченія_прямой_и_окружности(-10, 11, -11, 12, 3, -5, 3, True, "[]")
найти_точки_пересђченія_прямой_и_окружности(3, -2, 7, -2, 3, -5, 3, False, "(3, -2)")
найти_точки_пересђченія_прямой_и_окружности(0, -3, 0, 6, 0, 0, 4, False, "(0, 4)(0, -4)")
найти_точки_пересђченія_прямой_и_окружности(0, -3, 0, 6, 0, 0, 4, True, "(0, 4)")
найти_точки_пересђченія_прямой_и_окружности(6, 3, 10, 7, 4, 2, 5, False, "(8, 5)(1, -2)") 
найти_точки_пересђченія_прямой_и_окружности(7, 4, 11, 8, 4, 2, 5, True, "(8, 5)")
найти_точки_пересђченія_прямой_и_окружности(1, 0, 1, 5, 1, 3, 1, False, "(1, 4)(1, 2)")

